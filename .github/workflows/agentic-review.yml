name: Agentic Code Review

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  contents: read
  pull-requests: write

jobs:
  ai-review:
    runs-on: ubuntu-latest
    outputs:
      issues_found: ${{ steps.review.outputs.issues_found }}
      auto_merge_eligible: ${{ steps.review.outputs.auto_merge }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Get diff
        id: diff
        run: |
          git diff origin/${{ github.base_ref }}...HEAD > changes.diff
          echo "Diff size: $(wc -l < changes.diff) lines"
          
          # Store diff for analysis (truncate if huge)
          head -c 50000 changes.diff > truncated.diff

      - name: AI Review
        id: review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const diff = fs.readFileSync('truncated.diff', 'utf8');
            
            const issues = [];
            const warnings = [];
            const lines = diff.split('\n');
            
            let currentFile = '';
            let lineNum = 0;
            
            for (const line of lines) {
              // Track current file
              if (line.startsWith('+++ b/')) {
                currentFile = line.replace('+++ b/', '');
                lineNum = 0;
              }
              
              if (line.startsWith('+') && !line.startsWith('+++')) {
                lineNum++;
                const content = line.slice(1);
                
                // Security checks
                if (/password\s*=\s*['"][^'"]+['"]/i.test(content)) {
                  issues.push(`ðŸ”´ **SECURITY**: Hardcoded password in \`${currentFile}\``);
                }
                if (/api[_-]?key\s*=\s*['"][^'"]+['"]/i.test(content)) {
                  issues.push(`ðŸ”´ **SECURITY**: Hardcoded API key in \`${currentFile}\``);
                }
                if (/secret\s*=\s*['"][^'"]+['"]/i.test(content)) {
                  issues.push(`ðŸ”´ **SECURITY**: Hardcoded secret in \`${currentFile}\``);
                }
                
                // Code quality
                if (/console\.log\(/.test(content) && !/\/\/\s*(debug|TODO)/i.test(content)) {
                  warnings.push(`âš ï¸ Debug code: \`console.log\` in \`${currentFile}\``);
                }
                if (/TODO|FIXME|HACK|XXX/.test(content)) {
                  warnings.push(`ðŸ“ Found TODO/FIXME in \`${currentFile}\` - ensure tracked`);
                }
                
                // Config issues
                if (currentFile.endsWith('.yml') || currentFile.endsWith('.yaml')) {
                  if (/^\s+/.test(content) && /\t/.test(content)) {
                    warnings.push(`âš ï¸ Mixed tabs/spaces in YAML: \`${currentFile}\``);
                  }
                }
              }
            }
            
            // Build review comment
            let body = '## ðŸ¤– Agentic Code Review\n\n';
            
            const hasBlockers = issues.length > 0;
            const hasWarnings = warnings.length > 0;
            
            if (hasBlockers) {
              body += '### ðŸš« Blocking Issues\n\n';
              issues.forEach(i => body += `- ${i}\n`);
              body += '\n';
            }
            
            if (hasWarnings) {
              body += '### âš ï¸ Warnings\n\n';
              warnings.slice(0, 10).forEach(w => body += `- ${w}\n`);
              if (warnings.length > 10) {
                body += `- ... and ${warnings.length - 10} more\n`;
              }
              body += '\n';
            }
            
            if (!hasBlockers && !hasWarnings) {
              body += 'âœ… **No issues found. LGTM!**\n\n';
            }
            
            // Auto-merge eligibility
            const prAuthor = context.payload.pull_request.user.login;
            const isTrusted = ['dependabot[bot]', 'renovate[bot]'].includes(prAuthor) ||
                             context.payload.pull_request.labels?.some(l => l.name === 'auto-merge');
            
            const canAutoMerge = !hasBlockers && isTrusted;
            
            body += '---\n';
            body += `**Auto-merge eligible:** ${canAutoMerge ? 'âœ… Yes' : 'âŒ No'}`;
            if (!canAutoMerge) {
              if (hasBlockers) body += ' (blocking issues found)';
              else if (!isTrusted) body += ' (requires trusted author or auto-merge label)';
            }
            body += '\n\n*Reviewed by Agentic CI/CD Pipeline*';
            
            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
            
            // Set outputs
            core.setOutput('issues_found', hasBlockers ? 'true' : 'false');
            core.setOutput('auto_merge', canAutoMerge ? 'true' : 'false');
            
            // Fail if blocking issues
            if (hasBlockers) {
              core.setFailed('Blocking security issues found');
            }

  auto-merge:
    runs-on: ubuntu-latest
    needs: ai-review
    if: needs.ai-review.outputs.auto_merge_eligible == 'true'
    steps:
      - name: Wait for other checks
        run: sleep 30
        
      - name: Attempt auto-merge
        uses: actions/github-script@v7
        with:
          script: |
            // Check all status checks
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.pull_request.head.sha
            });
            
            const pending = checks.check_runs.filter(c => 
              c.status !== 'completed' && c.name !== 'auto-merge'
            );
            
            if (pending.length > 0) {
              console.log(`Waiting for ${pending.length} checks to complete`);
              return;
            }
            
            const failed = checks.check_runs.filter(c => 
              c.conclusion === 'failure' && c.name !== 'auto-merge'
            );
            
            if (failed.length > 0) {
              console.log('Some checks failed, skipping auto-merge');
              return;
            }
            
            console.log('All checks passed - merging');
            
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                merge_method: 'squash'
              });
              console.log('âœ… Auto-merged successfully');
            } catch (e) {
              console.log('Could not auto-merge:', e.message);
            }
